#if !defined(CONIO_INIT)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                          RetroZ SIO/2 Library                           ;;
;;                                                                         ;;
;; Version: 0.5.0                                                          ;;
;; https://github.com/formix/RetroZ-bios                                   ;;
;; By J.P. Gravel <jeanphilippe.gravel@gmail.com>                          ;;
;; 2019-09-25                                                              ;;
;;                                                                         ;;
;; This library creates a 64 bytes buffer where characters are stored      ;;
;; using the PUTCHAR subroutine. Character are then available to be        ;;
;; fetched by GETCHAR. This library also declares a KEY_PRESSED to recieve ;;
;; characters emitted by other libraries like a serial IO library          ;;
;; (sio2.z80) or any other character generating library.                   ;;
;;                                                                         ;;
;; This library declares a set of subroutines to add or remove characters  ;;
;; from the character buffer and prints characters using the OUTC          ;;
;; subroutine. Exposed subroutines are:                                    ;;
;;                                                                         ;;
;;  - CONIO_INIT: Initializes the library variables.                       ;;
;;  - PUTCHAR: Adds a charcater to the character buffer.                   ;;
;;  - GETCHAR: Gets a character from the character buffer.                 ;;
;;  - PRINT: Prints the zero terminated string recieved as param to OUTC.  ;;
;;                                                                         ;;
;; The library also expose the following variable:                         ;;
;;                                                                         ;;
;;  - BUFFER_STATE (byte): Current state of the circular buffer, either    ;;
;;         BUFFER_FULL, BUFFER_READY or BUFFER_EMPTY.                      ;;
;;                                                                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BUFFER_EMPTY    EQU     01000000b
BUFFER_READY    EQU     0
BUFFER_FULL     EQU     00000100b

#data           _HEAP
BUFFER          DEFS    64
BUFFER_HEAD     DEFS    2
BUFFER_TAIL     DEFS    2
BUFFER_STATE    DEFS    1


#code           _MAIN
CONIO_INIT:
        LD      HL,BUFFER
        LD      (BUFFER_HEAD),HL
        LD      (BUFFER_TAIL),HL
        LD      A,BUFFER_EMPTY
        LD      (BUFFER_STATE),A
        RET


KEY_PRESSED:    PUSH    AF              ;Add the character on the stack.
                CALL    PUTCHAR         ;Add the character to the buffer.
                POP     AF
                RET                     ;Cannot use the JP trick with stack
                                        ;parameters.

; ***************************************************************************
; Enqueue the character from the stack into the character buffer. This 
; subroutine should be called with interrupts disabled.
;       Input:  - The character (high byte), Don't care (low byte)
;       Return: Nothing
;       Flags:  Z is set if the buffer is full after the call
;               C is set if the call failed to add to the buf because it is
;               full.
; ***************************************************************************
PUTCHAR:        LD      A,(BUFFER_STATE);Check if the buffer is full
                CP      BUFFER_FULL
                JR      NZ,DO_ENQUEUE   ;If the buffer is not full, DO_ENQUEUE
                CP      A               ;set the Z flag,
                PUSH    IY              ;restore the return address
                RET                     ;and exit ***.
DO_ENQUEUE:     LD      HL,(BUFFER_HEAD);Load the buffer address into HL
                LD      IY,3            ;Get the byte to append from the first
                ADD     IY,SP           ;parameter on the stack.
                LD      A,(IY)
                LD      D,A             ;Save the character for later in D
                LD      (HL),A          ;Append the byte in the buffer
                LD      A,BUFFER_READY
                LD      (BUFFER_STATE),A;Buffer no longer empty here
                INC     L               ;Move the head forward
                RES     6,L             ;Modulo 64
                LD      (BUFFER_HEAD),HL;Save the new head value
                LD      A,(BUFFER_TAIL) ;Load tail index in A
                CP      L               ;Compare head and tail indices
                JP      NZ,BUF_NOT_FULL ;If the buffer is full 
                LD      A,BUFFER_FULL   
                LD      (BUFFER_STATE),A;then set the buffer state to FULL
BUF_NOT_FULL:   RET                     ;and exit ***.


; ***************************************************************************
; Dump the buffer content to the character output using OUTC.
;       Input:  Nothing
;       Return: Nothing
; ***************************************************************************
DUMP_BUFFER:    LD      A,(BUFFER_STATE)
                CP      BUFFER_EMPTY
                RET     Z               ;If the buffer is empty, return.
                LD      HL,(BUFFER_TAIL);Make HL the buffer cursor
DUMP_BYTE:      LD      A,(HL)
                CALL    OUTC            ;Print the buffer byte
                INC     L               ;Move the cursor to then next byte
                RES     6,L             ;Modulo 64
                LD      A,(BUFFER_HEAD)
                CP      L               ;Check if cursor reached the head
                RET     Z               ;Reached the head, return.
                JR      DUMP_BYTE       ;Print next byte

                
; ***************************************************************************
; Print end of line (\r\n)
; ***************************************************************************
PRINT_ENDL:     LD      A,10
                CALL    OUTC
                LD      A,13
                CALL    OUTC
                RET


; ***************************************************************************
; Dequeue one character from the circular buffer on the stack
;       Input:  - Nothing
;       Return: Register L contains the character read from the buffer.
;               If the buffer was empty, L contains NULL and Z is set.
; ***************************************************************************
GETCHAR:        DI                      ;Disable interrupts during execution
                LD      A,(BUFFER_STATE);Check if the buffer is empty
                CP      BUFFER_EMPTY
                JR      NZ,DO_DEQUEUE   ;If the buffer is not empty, DO_DEQUEUE
                XOR     A               ;Else set the Z flag,
                LD      L,0             ;set the renurned character to null,
                EI                      ;enable interrupts before leaving
                RET                     ;and exit.
DO_DEQUEUE:     LD      HL,(BUFFER_TAIL);Load the buf tail address into HL
                LD      IY,(BUFFER_TAIL);and into IY
                INC     L               ;Move the tail forward
                RES     6,L             ;Modulo 64
                LD      (BUFFER_TAIL),HL;Save the new tail value
                LD      A,(BUFFER_HEAD) ;Load head index in A
                CP      L               ;Compare head and tail indices
                JP      NZ,BUF_NOT_EMPTY;If the buffer is not empty, jump. 
                LD      A,BUFFER_EMPTY  ;else 
                LD      (BUFFER_STATE),A;  set the buffer state to EMPTY.
BUF_NOT_EMPTY:  OR      A               ;Reset the Z flag.
                LD      L,(IY)          ;Return the character value into L.
                EI                      ;enable interrupts before leaving
                RET                     ;and exit ***.


; ***************************************************************************
; Prints the NULL terminated string pointed by the parameter by calling
; OUTC. OUTC is expected to be implemented in another module.
;       Input: The NULL terminated string address.
;       Output: nothing.
; ***************************************************************************
PRINT:          POP     IY              ;Save the return addres
                POP     HL              ;Get the string address in HL.
PRINT_NEXT_CHAR:
                LD      A,(HL)          ;Reads the next character
                OR      A		;Check if that character is null.
                JR	Z,PRINT_EXIT	;If the null char is reached, exit.
                CALL    OUTC            ;Print the character and 
                INC     HL              ;move to the next char.
                JR      PRINT_NEXT_CHAR	;Print the next char
PRINT_EXIT:     PUSH    IY              ;Restore the return address
                RET                     ;and exit.




#endif
