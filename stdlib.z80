#if !defined(STDLIB_INIT)
#include "math.z80"

#data           _HEAP
ITOA_RESULT     DEFS    17


#code           _DATA
HEXA            DEFB    "0123456789ABCDEF"


#code           _MAIN
STDLIB_INIT:      RET







; ***************************************************************************
; Convert the value in BC to a null terminated string of base DE.
; The memory block pointed by IX is expected to be large enough to hold the 
; number plus the terminating NULL character.
; 
; for example, if DE is 2 then converts HL to a binary string.
;              if DE is 8, octal string
;              if DE is 10, decimal string
;              if DE is 16, hexadecimal string.
;              any value between 2 and 16 can be used as a base.
; ***************************************************************************
ITOA:           LD      IY,2
                ADD     IY,SP
                LD      C,(IY+2)        ; The converted value param
                LD      B,(IY+3)
                LD      E,(IY+4)        ; The conversion base param
                LD      D,(IY+5)

                ; Will put the character on the stack in the revers order
                ; Start by adding the null termination charcater on the stack.
                XOR     A               ; Reset A to NULL
                PUSH    AF              ; Add the NULL temination to the stack

                ; Do the modulo operation with the base to get the character
                ; index in the HEXA array (see above in the _DATA code segment).
ITOA_DECODE:    PUSH    DE              ; Add param on the stack (divisor).
                PUSH    BC              ; Add param on the stack (divised).
                CALL    MOD16           ; After the mod, the chr index is in HL
                POP     BC              ; Clear the stack param 1.
                ;POP     DE              ; Clear the stack param 2.

                ; The caracter index in HL, we now have to add it to the stack.
                ;PUSH    DE
                LD      DE,HEXA 
                ADD     HL,DE           ; Move HL to the hex char address
                POP     DE              ; Restore DE value (and clr stack p2)
                LD      A,(HL)          ; Get the character into A and
                PUSH    AF              ; add add it to the stack

                ; We substract the base from the initial number to get to the
                ; next character.
                LD      L,C             ; Move BC into HL
                LD      H,B
                CCF                     ; Clear the carry flag
                SBC     HL,DE           ; Substract the base from the number
                JR      C,ITOA_WRITE_I  ; If the result is negative, done
                LD      C,L             ; Put back the remains into BC
                LD      B,H
                JR      ITOA_DECODE     ; Decode the next character.

                ; We now have to unstack every character and put them in order
                ; in the string pointer provided as the first paramter.
ITOA_WRITE_I:   LD      L,(IY)          ; the target string param
                LD      H,(IY+1)
ITOA_WRITE:     POP     AF              ; Get the next character.
                LD      (HL),A          ; Write that char into the current pos.
                OR      0               ; Check if A contains 0
                RET     Z               ; if A contains the NULL char, GTFO
                INC     HL              ; Set the pointer to the next char pos.
                JR      ITOA_WRITE
                ; RETURNS WITHIN THE LOOP



#endif
