#if !defined(_SIO2_Z80)

; -------------- LABELS ----------------
SIOA_C          EQU     $00
SIOA_D          EQU     $01
SIOB_C          EQU     $02
SIOB_D          EQU     $03

ECHO_ON         EQU     1
ECHO_OFF        EQU     0

BUFFER_EMPTY    EQU     01000000b
BUFFER_READY    EQU     0
BUFFER_FULL     EQU     00000100b

; -------------- RAM HEAP (variables) ----------------
HEAP_START      EQU     $8000
BUFFER          EQU     HEAP_START
BUFFER_HEAD     EQU     HEAP_START+64   ;give one more byte for testing
BUFFER_TAIL     EQU     HEAP_START+66
BUFFER_STATE    EQU     HEAP_START+68
ECHO_STATE      EQU     HEAP_START+69
HEAP_END        EQU     HEAP_START+70


INT_VECTOR:     ORG     $000C
                DEFW    RX_CHA_AVAILABLE
                DEFW    SPEC_RX_CONDITION

_SIO2_Z80:      ORG     INT_VECTOR+20

SIO2_INIT:
        LD      HL,BUFFER
        LD      (BUFFER_HEAD),HL
        LD      (BUFFER_TAIL),HL
        LD      A,BUFFER_EMPTY
        LD      (BUFFER_STATE),A
        LD      A,ECHO_ON
        LD      (ECHO_STATE),A

        ; SIOA init
	LD      A,$00            ; write 0
	OUT     (SIOA_C),A
	LD      A,$18            ; reset ext/status interrupts
	OUT     (SIOA_C),A

	LD      A,$04            ; write 4
	OUT     (SIOA_C),A
	LD      A,$C4            ; X64, no parity, 1 stop
	OUT     (SIOA_C),A

	LD      A,$01            ; write 1
	OUT     (SIOA_C),A
	LD      A,$18            ; interrupt on all recv
	OUT     (SIOA_C),A

	LD      A,$03            ; write 3
	OUT     (SIOA_C),A
	LD      A,$E1            ; 8 bits, auto enable, rcv enab
	OUT     (SIOA_C),A

	LD      A,$05           ; write 5
	OUT     (SIOA_C),A
	LD      A,$EA		; dtr enable, 8 bits, tx enable, rts
	OUT     (SIOA_C),A

        ; SIOB init
	LD      A,$00
	OUT     (SIOB_C),A
	LD      A,$18
	OUT     (SIOB_C),A

	LD      A,$04            ; write 4
	OUT     (SIOB_C),A
	LD      A,$C4            ; X64, no parity, 1 stop
	OUT     (SIOB_C),A

	LD      A,$01
	OUT     (SIOB_C),A
	LD      A,$18
	OUT     (SIOB_C),A

	LD      A,$02           ; write reg 2
	OUT     (SIOB_C),A
	LD      A,$0C           ; INTERRUPT VECTOR ADDRESS
	OUT     (SIOB_C),A

	LD      A,$03
	OUT     (SIOB_C),A
	LD      A,$E1
	OUT     (SIOB_C),A

	LD      A,$05
	OUT     (SIOB_C),A
	LD      A,$EA
	OUT     (SIOB_C),A


; ***** SIOA ENABLE INTERRUPTS *****
SIOA_EI:
        LD      A, $03          ;write into WR0: select WR3
        OUT     (SIOA_C),A
        LD      A,$C1           ;RX 8bits, auto enable off, RX on
        OUT     (SIOA_C),A
        RET


; ***** SIOA DISABLE INTERRUPTS *****
SIOA_DI:
        LD      A,$03           ;write into WR0: select WR3
        OUT     (SIOA_C),A
        LD      A,$C0           ;RX 8bit, auto enable off, RX off
        OUT     (SIOA_C),A
        RET


INT_INIT:
        LD      A,0
        LD      I,A             ;load I reg with zero
        IM      2               ;interrupt mode 2
        EI                      ;enable interrupts
        RET


A_RTS_OFF:
        LD      A,$05           ;write into WR0: select WR5
        OUT     (SIOA_C),A
        LD      A,$E8           ;DTR active, TX 8bit, BREAK off, TX on, RTS off
        OUT     (SIOA_C),A
        RET


A_RTS_ON:
        LD      A,$05           ;write into WR0: select WR5
        OUT     (SIOA_C),A
        LD      A,$EA           ;DTR active, TX 8bit, BREAK off, TX on, RTS on
        OUT     (SIOA_C),A
        RET


RX_CHA_AVAILABLE:
        EX      AF,AF'          ;backup AF
        EXX
WAIT_RX:
	SUB	A		;Clears A
	OUT	(SIOA_C),A	;Select RR0
	IN	A,(SIOA_C)	;Read RR0
	BIT	0,A		;Check if character is available
	JR	Z,WAIT_RX	;Character not recieved yet, check again

        IN      A,(SIOA_D)      ; A holds recieved character
        
        ; do something with the character
        PUSH    AF
        
        PUSH    AF
        CALL    PUTCHAR
        
        POP     AF
        CALL    KEY_PRESSED

        EXX
        EX      AF,AF'
        EI
	RETI


SPEC_RX_CONDITION:
        JP      MAIN

; ***************************************************************************
; Enqueue the character from the stack into the character buffer.
;       Input:  - The character (high byte), Don't care (low byte)
;       Return: Nothing
;       Flags:  Z is set if the buffer is full after the call
;               C is set if the call failed to add to the buf because it is
;               full.
; ***************************************************************************
PUTCHAR:        POP     IY              ;Save the return address
                LD      A,(BUFFER_STATE);Check if the buffer is full
                AND     BUFFER_FULL     ;by looking at the BUFFER_FULL bit.
                CP      BUFFER_FULL
                JR      NZ,DO_ENQUEUE   ;If the buffer is not full, DO_ENQUEUE
                POP     AF              ;else pop the parameter from the stack
                CP      A               ;set the Z flag,
                SCF                     ;set the carry flag,
                PUSH    IY              ;restore the return address
                RET                     ;and exit ***.
DO_ENQUEUE:     LD      HL,(BUFFER_HEAD);Load the buffer address into HL
                POP     AF              ;Get the byte to append
                LD      D,A             ;Save the character for later in D
                LD      (HL),A          ;Append the byte in the buffer
                LD      A,BUFFER_READY
                LD      (BUFFER_STATE),A;Buffer no longer empty here
                INC     L               ;Move the head forward
                RES     6,L             ;Modulo 64
                LD      (BUFFER_HEAD),HL;Save the new head value
                LD      A,(BUFFER_TAIL) ;Load tail index in A
                CP      L               ;Compare head and tail indices
                JP      NZ,BUF_NOT_FULL ;If the buffer is full 
                LD      A,BUFFER_FULL   
                LD      (BUFFER_STATE),A;then set the buffer state to FULL
BUF_NOT_FULL:   LD      A,D             ;else, put the byte back into A
                PUSH    IY              ;Restore the return address
                RET                     ;and exit ***.


; ***************************************************************************
; Dump the buffer content to the character output using OUTC.
;       Input:  Nothing
;       Return: Nothing
; ***************************************************************************
DUMP_BUFFER:    LD      A,(BUFFER_STATE)
                AND     BUFFER_EMPTY
                CP      BUFFER_EMPTY
                RET     Z               ;If the buffer is empty, return.
                LD      HL,(BUFFER_TAIL);Make HL the buffer cursor
DUMP_BUFFER_1:  LD      A,(HL)
                CALL    OUTC            ;Print the buffer byte
                INC     L               ;Move the cursor to then next byte
                RES     6,L             ;Modulo 64
                LD      A,(BUFFER_HEAD)
                CP      L               ;Check if cursor reached the head
                RET     Z               ;Reached the head, return.
                JR      DUMP_BUFFER_1   ;Print next byte

                
; ***************************************************************************
; Print end of line (\r\n)
; ***************************************************************************
PRINT_ENDL:     LD      A,10
                CALL    OUTC
                LD      A,13
                CALL    OUTC
                RET


; ***************************************************************************
; Dequeue one character from the circular buffer on to the stack
;       Input:  - Nothing
;       Return: High byte: the character read from the buffer
;               Low byte: SUCCESS (00000000b) if a character have been read,
;                         BUFFER_EMPTY (0100000b) if the circular buf was 
;                         empty
;
;       Remark: POPing the return value into AF will set the Z flag if the
;               buffer was empty. Otherwise (success) the Z flag is reset.
; ***************************************************************************
GETCHAR:        LD      A,(BUFFER_STATE);Check if the buffer is empty
                AND     BUFFER_EMPTY    ;by looking at the BUFFER_EMPTY bit.
                CP      BUFFER_EMPTY
                JR      Z,DO_DEQUEUE    ;If the buffer is not empty, DO_DEQUEUE
                XOR     B               ;set the renurned character to null,
                LD      C,BUFFER_EMPTY  ;set the return status to BUFFER_EMPTY,
                PUSH    BC              ;push the return value on the stack
                RET                     ;and exit.
DO_DEQUEUE:     LD      A,(BUFFER_TAIL) ;Load the buf tail index into A.
                LD      L,A             ;Load the tail in L.
                LD      H,$80           ;Set H to the buffer page location.
                LD      B,(HL)          ;Load the current byte in B.
                LD      C,0             ;Load the SUCCESS value into C.
                PUSH    BC              ;Return on the stack.
                INC     L               ;Increment the tail value.
                RES     6,L             ;Modulo 64 (buffer is 64 bytes long).
                LD      A,(BUFFER_HEAD) ;Load the head value into A
                CP      L               ;to check if the buf is empty.
                JR      NZ,BUF_NOT_EMPTY;If the buffer is empty
                LD      A,BUFFER_EMPTY  ;Then set the buffer empty bit.
                LD      (BUFFER_STATE),A;and save that in the BUFFER_STATE
BUF_NOT_EMPTY   LD      (BUFFER_TAIL),HL;Save the tail position.
                RET                     ;Exit the subroutine.
         

; ***************************************************************************
; Sends the content of register A to SIOA_D.
; ***************************************************************************
OUTC:
	PUSH	AF              ; Store character
WAIT_TXA:        
	SUB     A		; Wait for previous transmission to end
	OUT     (SIOA_C),A
	IN      A,(SIOA_C)
	BIT     2,A             ; Set Zero flag if transmitting a character
	JR      Z,WAIT_TXA      ; Loop if still transmitting character
	BIT	3,A             ; Set zero flag if no data carrier is detected
	JR	Z,WAIT_TXA      ; Loop if no carrier detected.
	BIT	5,A             ; Set zero flag if not clear to send
	JR	Z,WAIT_TXA      ; Loop if not clear to send.
	POP     AF              ; Retrieve character
	OUT     (SIOA_D),A      ; Output the character
	RET


; ***************************************************************************
; Prints the NULL terminated string pointed by HL to SIOA_D.
; When this function returns, no register is modified.
; ***************************************************************************
PRINT: 
	PUSH	AF
	PUSH	HL
PRINT_NEXT_CHAR:
        LD      A,(HL)          ;Reads the next character
        OR      A		;Check if that character is null.
	JR	Z,PRINT_EXIT	;If the null char is reached, exit.
        CALL    OUTC            ;Print the character and 
        INC     HL              ;move to the next char.
        JR      PRINT_NEXT_CHAR	;Print the next char
PRINT_EXIT:
	POP	HL
	POP	AF
	RET


#endif
