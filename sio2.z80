

SIOA_C      EQU     $00                     ; SIO A control port
SIOA        EQU     $01                     ; SIO A data port
SIOB_C      EQU     $02                     ; SIO B control port
SIOB        EQU     $03                     ; SIO B data port


    macro sio2_write_config     &port, &register, &value
    ld a,&register
    out (&port),a
    ld a,$value
    out (&port),a
    endm

    macro sio2_read_config      &port, &register
    ld a,&register
    out (&port)
    in a,(&port)
    endm


#define PORTB_BUF_PAGE  $81

#data       _DEVICE_INT_VECTOR
    DEFS    RX_CHA_AVAILABLE_INT, 2
    DEFS    SPEC_RX_CONDITION_INT, 2


#data       _BIOS_VARIABLES
    DEFS    PORTB_BUF_SIZE, 1
    DEFS    PORTB_BUF_START, 1


sio2_init:
    ; PortA
    sio2_write_config SIOA_C, $00, $18  ; Reset port A
    sio2_write_config SIOA_C, $01, $00  ; no interrupt on recv char
    sio2_write_config SIOA_C, $03, $E1  ; 8 bits, auto enable, rcv enable
    sio2_write_config SIOA_C, $04, $C4  ; X64, no parity, 1 stop bit
    sio2_write_config SIOA_C, $05, $EA  ; dtr enable, 8 bits, tx enable, rts

    ; PortB
    sio2_write_config SIOB_C, $00, $18  ; Reset port A
    sio2_write_config SIOB_C, $01, $18  ; interrupt on all recv chararters
    sio2_write_config SIOB_C, $02, $0C  ; Sets the interrupt vector address
    sio2_write_config SIOB_C, $03, $E1  ; 8 bits, auto enable, rcv enable
    sio2_write_config SIOB_C, $04, $C4  ; X64, no parity, 1 stop bit
    sio2_write_config SIOB_C, $05, $EA  ; dtr enable, 8 bits, tx enable, rts

    ; PortB Buffer Initialization
    sub a
    ld (PORTB_BUF_SIZE),a
    ld (PORTB_BUF_START),a


    ; Interrupt initialization
    ld hl,RX_CHA_AVAILABLE              ; Load the handling subroutine into hl
    ld (RX_CHA_AVAILABLE_INT),hl        ; Save it into the matching interrupt
    ld hl,SPEC_RX_CONDITION             ; Load the handling subroutine into hl
    ld (SPEC_RX_CONDITION_INT),hl       ; Save it into the matching interrupt

    ; Initialize the interrupt page register
    ld a,$80                            ; Sets the page at 32k (first ram page)
    ld i,a                              ; Sets the interrupt page
    im 2                                ; Sets the processor in vectored interrupt mode
    ei                                  ; Enable interrupts

    ; will enable the SIOA interrupts
    ld c,SIOA_C

; ***** SIO ENABLE INTERRUPTS *****
; Inputs: c -> the port to talk to (SIOA_C or SIOB_C)
SIO_EI:
	ld a,$03    ;Write into WR0: select WR3
	out (c),a
	ld a,$C1                            ;RX 8bits, auto enable off, RX on
	out (c),a
	ret


; ***** SIOA DISABLE INTERRUPTS *****
; Inputs: c -> the port to talk to (SIOA_C or SIOB_C)
SIO_DI:
	ld a,$03                            ;write into WR0: select WR3
	out (c),a
	ld a,$C0                            ;RX 8bit, auto enable off, RX off
	out (c),a
	ret


; ***************************************************************************
; Sends the content of register A to (C).
; ***************************************************************************
OUTC:
	push af                             ; Store character
	dec c				                ; Set C to the control port
WAIT_TXC:        
	sub a                               ; Wait for previous transmission to end
	out (c),a
	in a,(c)
	bit 2,a                             ; Set Zero flag if transmitting a character
	jr z,WAIT_TXC                       ; Loop if still transmitting character
	bit 3,a                             ; Set zero flag if no data carrier is detected
	jr z,WAIT_TXC                       ; Loop if no carrier detected.
	bit 5,a                             ; Set zero flag if not clear to send
	jr z,WAIT_TXC                       ; Loop if not clear to send.
	pop af                              ; Retrieve character
	inc c				                ; Set C to the data port.
	out (c),a      		                ; Output the character
	ret


; ***************************************************************************
; Reads (C) into A. Blocks until a character is read.
; ***************************************************************************
INPC:
	sub a				                ; Clears A
	dec	c			                    ; Set C to the control port
INPC_WAIT:
	out (c),a			                ; Select RR0
	in a,(c)			                ; Read RR0
	bit	0,a				                ; Check if character is available
	jr z,INPC_WAIT                      ; Character not recieved yet, check again
	inc	c				                ; Set C to the data port.
    in a,(c)      		                ; A holds recieved character
	ret


; Saves all registers, read the typed character and call an extern subroutine
; called KEY_PRESSED to handle the key.
RX_CHA_AVAILABLE:
    di
    push af

; Port A triggers an interrupt on each recieved character.
WAIT_RXA:
    sub a                               ;Clears 'a'
    out (SIOA_C),a                      ;Select RR0
    in a,(SIOA_C)                       ;Read RR0
    bit 0,a                             ;Check if character is available in port A
    jr z,WAIT_RXA                       ;Character not recieved yet, check again
    in a,(SIOA)                         ;'a' holds recieved character
    call KEY_PRESSED                    ;Do something with the character

    ; TODO: input port B into the buffer
WAIT_RXA_READ:
    sub a
    out (SIOB_C),a
    in a, (SIOB_C)
    bit 0,a                             ;Check if character is available in port B
    jr z, WAIT_RXA_END


WAIT_RXA_END:
    pop af
    ei
    reti


SPEC_RX_CONDITION:
    jp $0000


